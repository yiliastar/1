# Creating Triggers
When creating a trigger you need to specify four pieces of information:
- The unique trigger name
- The table to which the trigger is to be associated
- The action that the trigger should respond to (DELETE, INSERT, or UPDATE)
- When the trigger should be executed (before or after processing)
### Tip
#### Keep Trigger Names Unique per Database 
In MySQL 5 trigger names must be unique per table, but not per database. This means that two tables in the same database can have triggers of the same name. This is not allowed in other DBMSs where trigger names must be unique per database, and it is very likely that MySQL will make the naming rules stricter in a future release. As such, it is a good idea to use database-wide unique trigger names now.


Triggers are created using the CREATE TRIGGER statement. Here is a really simple example:
- #### Input
```
CREATE TRIGGER newproduct AFTER INSERT ON products
FOR EACH ROW SELECT Product added;
```
- ####  Analysis
'CREATE TRIGGER' is used to create the newtrigger named 'newproduct'. triggers can be executed before or after an operation occurs, and here 'AFTER INSERT' is specified sothe trigger will execute after a successful 'INSERT' statement has been executed. The trigger then specifies 'FOR EACH ROW' and the code to be executed for each insertedrow. In this example, the text 'Product added' will be displayed once for each rowinserted.To test this trigger, use the 'INSERT' statement to add one or more rows to 'products'; you'll see the 'Product added' message displayed for each succesful insertion.
# Dropping Triggers
By nowthe syntax for dropping a trigger should be apparent. To drop a trigger, use the 'DROP TRIGGER' statement, as seen here:
- ####  Input
```
DROP TRIGGER newproduct;
```
# Using Triggers
With the basics covered, we will nowlook at each of the supported trigger types, and the differences between them.
### INSERT Triggers
INSERT triggers are executed before or after an INSERT statement is executed. Be aware of the following:
- Within 'INSERT Trigger' code, you can refer to a virtual table named NEW to access the rows being inserted.
- In a 'BEFORE INSERT' trigger, the values in 'NEW' may also be updated (allowing you to change values about to be inserted).
- For 'AUTO_INCREMENT' columns, 'NEW' will contain 0 before and the newautomatically generated value after.

- #### Input
```
CREATE TRIGGER neworder AFTER INSERT ON orders
FOR EACH ROW SELECT NEW.order_num;
```
- #### Analysis
The code creates a trigger named 'neworder' that is executed by 'AFTER INSERT ON orders'. When a neworder is saved in 'orders', MySQL generates a neworder number and saves it in 'order_num'.
This trigger simply obtains this value from 'NEW.order_num' and returns it. This trigger must be executed by 'AFTER INSERT' because before the 'BEFORE INSERT' statement is 'executed, the 'neworder_num' has not been generated yet. Using this trigger for every insertion into 'orders' will always return the neworder number.
To test this trigger, try inserting a neworder, like this:
- #### Input
```
INSERT INTO orders(order_date, cust_id)
VALUES(Now(), 10001);
```
- #### Output
```
+-----------+
          
| order_num |
          
+-----------+
          
|   20010    |
          
+-----------+
```

- #### Analysis
'orders' contains three columns. order_date and cust_id must be specified, 'order_num' is automatically generated by MySQL, and 'order_num' is also nowreturnedautomatically.
# DELETE triggers
'DELETE' triggers are executed before or after a DELETE statement is executed. Be aware of the following:
- Within 'DELETE' trigger code, you can refer to a virtual table named OLD to access the rows being deleted.
- The values in OLD are all read-only and cannot be updated.
The following example demonstrates the use of OLD to save rows about to be deleted into an archive table:
- #### Input
```
CREATE TRIGGER deleteorder BEFORE DELETE ON orders
FOR EACH ROW
BEGIN
    INSERT INTO archive_orders(order_num, order_date,cust_id)
    VALUES(OLD.order_num, OLD.order_date, OLD.cust_id);
END;
```
- ####  Analysis
Before any order is deleted this trigger will be executed. It used an 'INSERT' statement to save the values in 'OLD' (the order about to be deleted) into an ''archive tablenamed 'archive_orders'. (To actually use this example you'll need to create a table named 'archive_orders' with the same columns as 'orders').
The advantage of using a 'BEFORE DELETE' TRigger (as opposed to an 'AFTER DELETE' TRigger) is that if, for some reason, the order could not be archived, the 'DELETE' itself will be aborted.
# UPDATE triggers
'UPDATE' triggers are executed before or after an 'UPDATE' statement is executed. Be aware of the following:
- Within 'UPDATE' trigger code, you can refer to a virtual table named 'OLD' to access the previous (pre-UPDATE statement) values and 'NEW' to access the new updated values.
- In a 'BEFORE UPDATE' trigger, the values in 'NEW' may also be updated (allowing you to change values about to be used in the 'UPDATE' statement).
- The values in 'OLD' are all read-only and cannot be updated.
The following example ensures that state abbreviations are always in uppercase (regardless of howthey were actually specified in the 'UPDATE' statement):
- #### Input
```
CREATE TRIGGER updatevendor BEFORE UPDATE ON vendors
FOR EACH ROW SET NEW.vend_state = Upper(NEW.vend_state);
```
- ####  Analysis
Obviously, any data cleanup needs to occur in the 'BEFORE UPDATE' statement as it does in this example. Each time a rowis updated, the value in 'NEW.vend_state' (thevalue that will be used to update table rows) is replaced with Upper('NEW.vend_state').
